# 堆排序

构建最大最小堆。第i次将倒数第i个元素不考虑。
时间复杂度为O(n logn)


最大堆：一棵完全树，且所有的根节点的数的都比子节点的数要大，那么就说这是一个最大堆

完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树

对应于数组的情况
`[0]` 的子节点是`[1] [2]`。`[1]` 的子节点是`[3] [4]`。`[2]`的子节点是`[5] [6]`….以此类推
第i个节点的左子节点为`2*i+1`, 右子节点为`2*i+2`, 它的父节点为 `(i-1)/2`向下取整。
这样就，将一个数组物化为了一个二叉树。

**算法思路：找到最大那个数，将这个数放到数组的最后面。**


* 构建最大堆
* 那么第一个数就是最大的那个数，将其与最后的数值交换。O(n logn)
* 只考虑前n-1数的话，则需要相当于一个需要维护的最大堆，需要的复杂度为O(log n)
* 依次的将每一轮中最大数值放到最后，然后不断缩小这个堆直到所有的节点都出来，即完成排序。


